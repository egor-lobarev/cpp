# Реализация шаблонного класса Vector

Данный проект представляет собой реализацию шаблонного класса `Vector`, который предоставляет функциональность динамического массива с ручным управлением памятью.

## Реализованные возможности

1. **Конструкторы:**
   - **Конструктор по умолчанию**: создает пустой массив.
   - **Явный конструктор от числа**: создает массив заданного размера, заполненный объектами, сконструированными по умолчанию.
   - **Конструктор, принимающий `size` и `value`**: создает массив длины `size`, заполненный элементами со значением `value`.
   - **Шаблонный конструктор, принимающий пару итераторов**: реализован с учетом строгих требований, предъявляемых к типам итераторов (Forward итераторы).
   - **Конструктор от `std::initializer_list`**: позволяет создавать массивы с использованием списков инициализации.

2. **Правило "пяти":**
   - Поддерживаются все необходимые методы для корректной работы с копированием и перемещением объектов.

3. **Основные методы:**
   - **Size**: возвращает количество элементов в массиве.
   - **Capacity**: возвращает текущую вместимость массива.
   - **Empty**: проверяет, пустой ли массив.
   - **Операторы доступа по индексу `[]` и метод `At`**: доступны как константные, так и неконстантные версии.
   - **Методы `Front()` и `Back()`**: доступ к первому и последнему элементам массива.
   - **Метод `Data()`**: возвращает указатель на начало массива.
   - **Метод `Swap(other)`**: обменивает содержимое с другим массивом `other`.
   - **Методы `Resize(new_size)` и `Resize(new_size, value)`**: изменяют размер массива с учетом новой вместимости.
   - **Метод `Reserve(new_cap)`**: изменяет вместимость массива.
   - **Метод `ShrinkToFit()`**: уменьшает вместимость до текущего размера.
   - **Метод `Clear()`**: устанавливает размер в 0, но не очищает выделенную память.
   - **Методы `PushBack(const T&)` и `PushBack(T&&)`**: добавляют новый элемент в конец массива.
   - **Метод `PopBack()`**: удаляет последний элемент.

4. **Операции сравнения:** 
   - Реализованы операции сравнения (`<`, `>`, `<=`, `>=`, `==`, `!=`), задающие лексикографический порядок.

5. **Поддержка итераторов:**
   - Реализованы методы для работы с итераторами: `begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()`, `crbegin()`, `crend()`.
   - Поддерживаются как константные, так и неконстантные итераторы.

6. **Типы-члены класса:**
   - Внутри класса `Vector` определены типы-члены: `ValueType`, `Pointer`, `ConstPointer`, `Reference`, `ConstReference`, `SizeType`, `Iterator`, `ConstIterator`.

7. **Гарантии безопасности:**
   - Методы класса спроектированы с учетом строгих гарантий безопасности: в случае возникновения исключений объект не изменяет своего состояния (за исключением копирующего присваивания, которое предоставляет базовую гарантию безопасности).
   - Предполагается, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений.

## Дополнительная часть: работа с памятью

- **Ручное управление памятью**: реализована поддержка ручного управления памятью через `placement new`, а также ручное удаление объектов с помощью деструкторов.
- **Использование алгоритмов STL**: для работы с неинициализированной памятью используются алгоритмы из секции `uninitialized storage` стандартной библиотеки C++.
- **Директива `#define VECTOR_MEMORY_IMPLEMENTED`** добавлена в код, что подтверждает реализацию данной части.

## Файловая структура

Реализация представлена в единственном файле `vector.h`, содержащем определение класса `Vector`.

## Проверка и тестирование

- **Функциональные тесты**: протестирована работа всех методов в соответствии с требованиями.
- **Проверка эффективности**: проведены тесты на корректность мультипликативной схемы расширения массива и работу с памятью.
- **Проверка на утечки памяти**: убедились, что нет утечек памяти и некорректных обращений к памяти.

## Заключение

Класс `Vector` реализует основные возможности динамического массива с поддержкой сложных операций управления памятью и строгими гарантиями безопасности, что делает его мощным инструментом для работы в современных C++ проектах.
